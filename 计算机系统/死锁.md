#死锁
##产生死锁的四个必要条件
- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。
##处理方法
- 鸵鸟策略
把头埋在沙子里，假装根本没发生问题。
因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。
当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。
大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。
- 死锁检测与死锁恢复
死锁检测:
两种情况。
死锁恢复:
（1）抢占：不通知原进程的情况下，将某一资源从一个进程强行取走给另一个进程使用，接着送回。
（2）回滚：周期性对进程进行检查点检查，即将进程的状态写入一个文件以备以后重启，包括存储映象、资源状态，即哪些资源分配给了哪些进程。新的检查点不覆盖原有的文件，而是写到新文件中。检测到死锁时，从一个较早的检查点开始，将该进程复位到更早的状态。
（3）杀死进程：杀死环中的一个或多个进程；杀死一个环外的进程以释放该进程的资源。（最好杀死可以从头开始重新运行且不会带来副作用的进程）
- 死锁预防

- 死锁避免

***
[参考文章](https://blog.csdn.net/qq_22238021/article/details/80225459)
###死锁预防
在程序运行之前预防发生死锁。
1. 破坏互斥条件
例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。
2. 破坏占有和等待条件
一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。
3. 破坏不可抢占条件
4. 破坏环路等待
给资源统一编号，进程只能按编号顺序来请求资源。
###死锁避免
1.一次封锁法：每个进程（事务）将所有要使用的数据全部加锁，否则，就不能继续执行；
2.顺序封锁法：预先对数据对象规定一个封锁顺序，所有进程（事务）都按这个顺序加锁；
3.银行家算法：保证进程处于安全进程序列。
[银行家算法](https://blog.csdn.net/wyf2017/article/details/80068608)

