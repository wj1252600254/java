#Java垃圾回收
##判定对象是否已死
1.引用计数法
2.可达性分析算法
从GC Roots 的对象作为起始点，从这些节点开始往下搜索，搜索所走过的路径成为引用链。
GC Roots包含的对象:
1.虚拟机栈(栈帧中的本地变量表)中引用的对象。
2.方法区中静态属性引用的对象
3.方法区中常量引用的对象
4.本地方法栈JNI引用的对象
##四种引用类型
* 强引用
* 软引用
* 弱引用
* 虚引用
##对象死亡过程
```
//主动调用GC的方法，并不保证执行，只是建议
System.gc();
// 或者下面，两者等价
Runtime.getRuntime().gc();
```
需要经过两次标记过程。
可达性分析后，对象没有与GC Roots相连，被第一次标记且进行筛选(看对象是否有必要执行finalize())。当对象没有覆盖finalize()或者已经执行过，都被视为没有必要执行。
如果有必要执行finailize()方法，会把对象加入F-Queue队列中，并在稍后有一个优先级低的线程去执行它。并不保证方法执行完。
##回收方法区
常量：没有任何对象引用常量。
类：必须满足3个条件
1.该类的所有实例已经被回收；
2.加载该类的ClassLoader已经被回收
3.该类对应的java.lang.Class对象没有在任何地方呗引用
##垃圾收集算法
1.标记-清除算法
2.复制算法
Eden和Survivor的大小比例为8:1
3.标记整理算法
##Hotspot算法实现
1.枚举根节点
准确式GC
实现方法：使用OopMap的数据结构来达到这个目的地，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么数据类型的数据计算出来。
2.安全点
OopMap只会在安全点停顿下来开始GC。
抢占式中断和主动式中断。
3.安全区域
sleep，blocked状态的线程。
##垃圾收集器
Serial、Parnew、Parallel scavenge(吞吐量，新生代)、serial old、parallel old、cms(老年代，响应速度)、g1。
* CMS
初始标记，并发标记，重新标记，并发清除
缺点：
1.对CPU资源非常敏感
2.无法处理浮动垃圾
3.产生大量空间碎片
* G1
Remembered Set
初始标记、并发标记、最终标记、筛选回收
特点：
并发与并行；
分代收集；保留了分代的概念，但不需要和其他收集器配合。
空间整合；标记-整理，基于复制实现的，不会产生空间碎片
可预测的停顿；
##内存分配与回收策略
1.对象优先在eden分配
2.大对象直接进入老年代
3.长期存活对象将进入老年代   默认年龄是15
4.动态对象年龄判定    survivor相同年龄的所有对象的大小占总空间的50%以上。
5.空间分配担保  检查老年最大可用连续空间是否大于新生代所有对象的总空间，如果满足，Minor GC可以确保是安全的。不成立，查看虚拟机是否允许担保失败。如果允许，看最大可用的连续空间是否发育历次晋升到老年代对象的平均大小，如果大于，进行一次Minor GC,小于进行 Full GC。
minor GC  新生代，在eden区域满了以后
major GC(FULL GC)老年代和新生代   在老年代放不下



